version: "1.0"
name: "shimmy_auto_discovery_implementation"
description: "Implement auto-discovery filesystem scanning for shimmy using champion LLM guidance"
steps:
  - id: "analyze_auto_discovery_requirements"
    name: "Analyze auto-discovery requirements"
    step_type: "llm"
    parameters:
      prompt: "I need to implement auto-discovery for shimmy that scans filesystems for AI models (GGUF, SafeTensors, ONNX) and automatically populates a model registry. Based on your knowledge of my coding patterns and Rust best practices, help me design: 1) File scanner architecture 2) Format detection strategy 3) Registry data structures 4) Integration with existing shimmy API. Keep it practical and focused."
      model: "llama32-champion"
      temperature: 0.2
      max_tokens: 600

  - id: "create_discovery_module_plan"
    name: "Create discovery module implementation plan"
    step_type: "create_file"
    depends_on: ["analyze_auto_discovery_requirements"]
    parameters:
      path: "../shimmy/AUTO_DISCOVERY_PLAN.md"
      content: "# Shimmy Auto-Discovery Implementation Plan\n\nGenerated by RustChain + Champion LLM\n\n## Implementation Strategy\n\n[Plan will be populated from LLM analysis]\n\n## Next Steps\n\n1. Implement file scanner\n2. Add format detection\n3. Create registry integration\n4. Test with sample models\n"

  - id: "design_file_scanner"
    name: "Design file scanner implementation"
    step_type: "llm"
    parameters:
      prompt: "For the shimmy file scanner component, I need to implement recursive directory scanning to find model files. Design a Rust module that: 1) Uses async/await for performance 2) Supports configurable file extensions (.gguf, .safetensors, .onnx) 3) Handles large directories efficiently 4) Provides progress reporting 5) Follows my coding patterns with proper error handling. Give me the module structure and key functions."
      model: "llama32-champion"
      temperature: 0.2
      max_tokens: 500

  - id: "design_format_detection"
    name: "Design format detection logic"
    step_type: "llm"
    parameters:
      prompt: "For shimmy's model format detection, I need to identify GGUF, SafeTensors, and ONNX files accurately. Design detection logic that: 1) Reads file headers/magic bytes 2) Validates format integrity 3) Extracts metadata (model name, size, architecture) 4) Handles corrupted/partial files gracefully 5) Uses Rust traits for extensibility. What's the best approach for each format?"
      model: "llama32-champion" 
      temperature: 0.2
      max_tokens: 500

  - id: "plan_registry_integration"
    name: "Plan registry integration"
    step_type: "llm"
    parameters:
      prompt: "For shimmy's model registry integration with auto-discovery, design how discovered models should be: 1) Stored in the registry data structure 2) Exposed via the existing API endpoints 3) Managed (add/remove/update) 4) Persisted between restarts 5) Integrated with the current engine system. Focus on backward compatibility with existing shimmy architecture."
      model: "llama32-champion"
      temperature: 0.2
      max_tokens: 400

  - id: "create_implementation_roadmap"
    name: "Create implementation roadmap"
    step_type: "create_file"
    depends_on: ["design_file_scanner", "design_format_detection", "plan_registry_integration"]
    parameters:
      path: "../shimmy/DISCOVERY_IMPLEMENTATION_ROADMAP.md"
      content: "# Shimmy Auto-Discovery Implementation Roadmap\n\nGenerated by RustChain Champion Analysis\n\n## Phase 1: File Scanner\n- Implement async directory traversal\n- Add configurable file filtering\n- Include progress reporting\n\n## Phase 2: Format Detection\n- GGUF header parsing\n- SafeTensors validation\n- ONNX format support\n- Metadata extraction\n\n## Phase 3: Registry Integration\n- Dynamic model registration\n- API endpoint updates\n- Persistence layer\n- Testing framework\n\n## Implementation Priority\n1. Start with file scanner (foundation)\n2. Add basic GGUF detection (most common)\n3. Integrate with existing registry\n4. Expand to other formats\n5. Add comprehensive testing\n"

config:
  max_parallel_steps: 1
  timeout_seconds: 120
