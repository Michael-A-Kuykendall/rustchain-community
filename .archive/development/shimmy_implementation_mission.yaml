name: "shimmy_auto_discovery_implementation"
description: "Implement auto-discovery features for Shimmy based on champion LLM analysis"
version: "1.0"
variables:
  shimmy_path: "/c/Users/micha/repos/shimmy"

steps:
  - id: analyze_shimmy_structure
    name: analyze_shimmy_structure
    step_type: llm
    depends_on: []
    parameters:
      provider: ollama
      model: llama32-champion
      temperature: 0.3
      max_tokens: 2000
      system: |
        You are the champion LLM that knows this user's development patterns very well.
        Analyze the shimmy codebase structure and identify where to add auto-discovery features.
        Focus on the model registry, file scanning, and format detection.
      prompt: |
        Based on your knowledge of this user's projects and the shimmy codebase, design the auto-discovery implementation:
        
        1. Analyze src/model_registry.rs - how to extend it for discovered models
        2. Design src/discovery.rs - filesystem scanning for GGUF files
        3. Plan integration with CLI commands (list, probe) 
        4. Consider environment variable paths and recursive scanning
        5. Design model metadata extraction from GGUF headers
        
        Provide specific Rust code structure and implementation approach.

  - id: create_discovery_module
    name: create_discovery_module
    step_type: create_file
    depends_on: [analyze_shimmy_structure]
    parameters:
      path: "${shimmy_path}/src/discovery.rs"
      content: |
        use std::path::{Path, PathBuf};
        use std::fs;
        use anyhow::{Result, anyhow};
        use serde::{Deserialize, Serialize};

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct DiscoveredModel {
            pub name: String,
            pub path: PathBuf,
            pub size_bytes: u64,
            pub format: ModelFormat,
            pub metadata: Option<ModelMetadata>,
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub enum ModelFormat {
            Gguf,
            SafeTensors,
            Unknown,
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ModelMetadata {
            pub architecture: Option<String>,
            pub parameter_count: Option<u64>,
            pub quantization: Option<String>,
        }

        pub struct ModelDiscovery {
            search_paths: Vec<PathBuf>,
        }

        impl ModelDiscovery {
            pub fn new() -> Self {
                let mut search_paths = Vec::new();
                
                // Add environment variable paths
                if let Ok(base_path) = std::env::var("SHIMMY_BASE_GGUF") {
                    if let Some(parent) = Path::new(&base_path).parent() {
                        search_paths.push(parent.to_path_buf());
                    }
                }
                
                // Add common model directories
                if let Ok(home) = std::env::var("HOME") {
                    search_paths.push(PathBuf::from(home).join(".cache/huggingface"));
                    search_paths.push(PathBuf::from(home).join("models"));
                }
                
                Self { search_paths }
            }

            pub fn discover_models(&self) -> Result<Vec<DiscoveredModel>> {
                let mut models = Vec::new();
                
                for search_path in &self.search_paths {
                    if search_path.exists() {
                        self.scan_directory(search_path, &mut models)?;
                    }
                }
                
                Ok(models)
            }

            fn scan_directory(&self, dir: &Path, models: &mut Vec<DiscoveredModel>) -> Result<()> {
                for entry in fs::read_dir(dir)? {
                    let entry = entry?;
                    let path = entry.path();
                    
                    if path.is_dir() {
                        self.scan_directory(&path, models)?;
                    } else if self.is_model_file(&path) {
                        if let Ok(model) = self.analyze_model_file(&path) {
                            models.push(model);
                        }
                    }
                }
                Ok(())
            }

            fn is_model_file(&self, path: &Path) -> bool {
                if let Some(ext) = path.extension() {
                    matches!(ext.to_str(), Some("gguf") | Some("safetensors"))
                } else {
                    false
                }
            }

            fn analyze_model_file(&self, path: &Path) -> Result<DiscoveredModel> {
                let metadata = fs::metadata(path)?;
                let format = self.detect_format(path)?;
                
                let name = path
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unknown")
                    .to_string();

                Ok(DiscoveredModel {
                    name,
                    path: path.to_path_buf(),
                    size_bytes: metadata.len(),
                    format,
                    metadata: self.extract_metadata(path).ok(),
                })
            }

            fn detect_format(&self, path: &Path) -> Result<ModelFormat> {
                match path.extension().and_then(|s| s.to_str()) {
                    Some("gguf") => Ok(ModelFormat::Gguf),
                    Some("safetensors") => Ok(ModelFormat::SafeTensors),
                    _ => Ok(ModelFormat::Unknown),
                }
            }

            fn extract_metadata(&self, path: &Path) -> Result<ModelMetadata> {
                // For now, just return basic metadata
                // TODO: Parse GGUF headers for actual model info
                Ok(ModelMetadata {
                    architecture: None,
                    parameter_count: None,
                    quantization: None,
                })
            }
        }

  - id: update_model_registry
    name: update_model_registry
    step_type: llm
    depends_on: [create_discovery_module]
    parameters:
      provider: ollama
      model: llama32-champion
      temperature: 0.2
      max_tokens: 1500
      system: |
        You know this user's coding style well. Generate the updated model_registry.rs file
        that integrates with the new discovery module while maintaining existing functionality.
      prompt: |
        Update the model registry to:
        1. Import and use the discovery module
        2. Add auto-discovery to the list command
        3. Keep existing manual model registration
        4. Merge discovered models with registry
        
        Provide the complete updated src/model_registry.rs file content.
